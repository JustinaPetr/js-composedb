"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3153],{4852:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>m});var n=a(9231);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(a),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return a?n.createElement(h,i(i({ref:t},d),{},{components:a})):n.createElement(h,i({ref:t},d))}));function m(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},8122:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var n=a(9675),o=(a(9231),a(4852));const r={},i="Data Modeling Concepts",s={unversionedId:"data-modeling-concepts",id:"data-modeling-concepts",title:"Data Modeling Concepts",description:"Models",source:"@site/docs/data-modeling-concepts.mdx",sourceDirName:".",slug:"/data-modeling-concepts",permalink:"/docs/preview/data-modeling-concepts",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"Graph",permalink:"/docs/preview/graph-structure"},next:{title:"Database",permalink:"/docs/preview/database"}},l={},c=[{value:"Models",id:"models",level:2},{value:"Language",id:"language",level:3},{value:"Validation",id:"validation",level:3},{value:"Relations",id:"relations",level:2},{value:"Composites",id:"composites",level:2},{value:"Data Model Catalog",id:"data-model-catalog",level:2}],d={toc:c};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"data-modeling-concepts"},"Data Modeling Concepts"),(0,o.kt)("h2",{id:"models"},"Models"),(0,o.kt)("p",null,"Models are\xa0",(0,o.kt)("a",{parentName:"p",href:"https://developers.ceramic.network/learn/advanced/overview/#streams"},"Ceramic streams"),"\xa0storing metadata about\xa0",(0,o.kt)("a",{parentName:"p",href:"/docs/preview/graph-structure#documents"},"documents"),". This metadata includes their discovery information as well as data structure/schema,\xa0validation rules, and\xa0relations. "),(0,o.kt)("h3",{id:"language"},"Language"),(0,o.kt)("p",null,"Models are written using a subset of the GraphQL Schema Definition Language (GraphQL SDL). "),(0,o.kt)("h3",{id:"validation"},"Validation"),(0,o.kt)("p",null,"Schema validation: All\xa0documents ","\xa0in ComposeDB must use a model, which contains information about the data structure the document must conform to. The validation is performed directly by all Ceramic nodes, allowing application to have guaranties about the documents they interact with even if they don't implement validation themselves."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Ceramic uses\xa0",(0,o.kt)("a",{parentName:"p",href:"https://json-schema.org/specification-links.html#2020-12"},"draft 2020-12 of the JSON Schema specification"),"\xa0to define the data structure and validation rules of documents.")),(0,o.kt)("h2",{id:"relations"},"Relations"),(0,o.kt)("p",null,"As in other property graphs, on ComposeDB you need a way to define which properties within a document can store relations to other documents."),(0,o.kt)("p",null,"ComposeDB uses models to define direct relations between\xa0accounts and documents with different constraints. In the near future, Account to Account relations, which will enable use cases like follower graphs will be supported."),(0,o.kt)("h2",{id:"composites"},"Composites"),(0,o.kt)("p",null,"Composites are composable building blocks used by developers. They are groups of data models (e.g. profiles, blog posts, and comments) that together define the graph database schema for an application. "),(0,o.kt)("p",null,"Content streams in Ceramic have metadata that automatically associates them to a data model",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},","))," which defines the shape and schema of that data, as well as to accounts and other content (e.g. User X liked a post by User Y). "),(0,o.kt)("p",null,"The ComposeDB developer tools and client library use complementary representations of composites to support various development flows such as managing data models, deploying them to Ceramic nodes and generating the runtime\xa0",(0,o.kt)("a",{parentName:"p",href:"https://graphql.org/"},"GraphQL"),"\xa0schema applications can interact with."),(0,o.kt)("h2",{id:"data-model-catalog"},"Data Model Catalog"),(0,o.kt)("p",null,"Composites and their underlying data models are designed to be reusable, making it simple to build complementary and interoperable apps. Apps that reuse each other's composites create instant interoperability, without any integrations needed. To date, developers on Ceramic have had to manually submit data models to the Registry on Github. Models are now automatically indexed, enabling easier discovery and reuse. Currently, discovering existing models happens through commands in the ComposeDB CLI, but we\u2019ll follow closely with a UI."))}p.isMDXComponent=!0}}]);